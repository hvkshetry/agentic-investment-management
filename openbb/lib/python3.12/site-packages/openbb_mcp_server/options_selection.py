"""Options chain selection strategies for institutional investors.

This module provides filtering strategies to reduce large options chains
to a manageable size while preserving the most relevant contracts for
specific investment workflows.
"""

import logging
from typing import Any, Callable, Dict, List, Optional
import pandas as pd
import numpy as np

logger = logging.getLogger(__name__)


class SelectionContext:
    """Context information for selection strategies."""

    def __init__(self, underlying_price: Optional[float] = None, **kwargs):
        self.underlying_price = underlying_price
        self.kwargs = kwargs

    @classmethod
    def from_data(cls, data: Dict[str, Any]) -> "SelectionContext":
        """Extract context from options chain data."""
        underlying_price = None

        # Try to get underlying price from metadata or first contract
        if isinstance(data, dict):
            metadata = data.get('underlying', {})
            underlying_price = metadata.get('price') or metadata.get('last_price')

            if not underlying_price and 'chains' in data:
                chains = data['chains']
                if chains and isinstance(chains, list):
                    underlying_price = chains[0].get('underlying_price')

        return cls(underlying_price=underlying_price)


def _liquidity_high_open_interest(df: pd.DataFrame, context: SelectionContext, limit: int) -> pd.DataFrame:
    """Select contracts with highest open interest."""
    if 'open_interest' not in df.columns:
        logger.warning("open_interest column not found, returning all data")
        return df

    return df.nlargest(limit, 'open_interest')


def _liquidity_high_volume(df: pd.DataFrame, context: SelectionContext, limit: int) -> pd.DataFrame:
    """Select contracts with highest volume."""
    if 'volume' not in df.columns:
        logger.warning("volume column not found, falling back to open_interest")
        return _liquidity_high_open_interest(df, context, limit)

    # Filter out zero volume first
    df_with_volume = df[df['volume'] > 0]
    if len(df_with_volume) >= limit:
        return df_with_volume.nlargest(limit, 'volume')
    else:
        # Fallback: use all with volume + fill with high OI
        remaining = limit - len(df_with_volume)
        df_no_volume = df[df['volume'] == 0].nlargest(remaining, 'open_interest')
        return pd.concat([df_with_volume, df_no_volume])


def _liquidity_tight_spread(df: pd.DataFrame, context: SelectionContext, limit: int) -> pd.DataFrame:
    """Select contracts with tightest bid-ask spreads."""
    if 'bid' not in df.columns or 'ask' not in df.columns:
        logger.warning("bid/ask columns not found, falling back to open_interest")
        return _liquidity_high_open_interest(df, context, limit)

    # Calculate spread as percentage of mid price
    df = df.copy()
    mid = (df['bid'] + df['ask']) / 2
    df['spread_pct'] = np.where(mid > 0, ((df['ask'] - df['bid']) / mid) * 100, 999.0)

    # Filter out invalid spreads
    df_valid = df[df['spread_pct'] < 100]
    if len(df_valid) >= limit:
        return df_valid.nsmallest(limit, 'spread_pct').drop(columns=['spread_pct'])
    else:
        return df_valid.drop(columns=['spread_pct'])


def _liquidity_composite(df: pd.DataFrame, context: SelectionContext, limit: int) -> pd.DataFrame:
    """Select contracts using composite liquidity score."""
    df = df.copy()

    # Normalize each component to 0-1 scale
    if 'open_interest' in df.columns and df['open_interest'].max() > 0:
        df['oi_score'] = df['open_interest'] / df['open_interest'].max()
    else:
        df['oi_score'] = 0

    if 'volume' in df.columns and df['volume'].max() > 0:
        df['vol_score'] = df['volume'] / df['volume'].max()
    else:
        df['vol_score'] = 0

    # Spread score (lower is better, so invert)
    if 'bid' in df.columns and 'ask' in df.columns:
        mid = (df['bid'] + df['ask']) / 2
        spread_pct = np.where(mid > 0, ((df['ask'] - df['bid']) / mid) * 100, 100.0)
        spread_pct_capped = np.minimum(spread_pct, 100.0)
        df['spread_score'] = 1 - (spread_pct_capped / 100.0)
    else:
        df['spread_score'] = 0

    # Composite: 50% OI, 30% volume, 20% spread
    df['liquidity_score'] = (
        0.5 * df['oi_score'] +
        0.3 * df['vol_score'] +
        0.2 * df['spread_score']
    )

    result = df.nlargest(limit, 'liquidity_score')
    return result.drop(columns=['oi_score', 'vol_score', 'spread_score', 'liquidity_score'])


def _moneyness_at_the_money(df: pd.DataFrame, context: SelectionContext, limit: int) -> pd.DataFrame:
    """Select at-the-money contracts (within ±1 strike or delta ~0.5)."""
    if not context.underlying_price:
        logger.warning("underlying_price not available, falling back to open_interest")
        return _liquidity_high_open_interest(df, context, limit)

    if 'strike' not in df.columns:
        logger.warning("strike column not found")
        return df

    # Calculate distance from ATM
    df = df.copy()
    df['distance_from_atm'] = abs(df['strike'] - context.underlying_price)

    # Get closest strikes (typically 1-3 strikes around ATM)
    atm_contracts = df.nsmallest(min(limit, 20), 'distance_from_atm')

    # If we need more, fill with high liquidity
    if len(atm_contracts) < limit:
        remaining = limit - len(atm_contracts)
        remaining_df = df[~df.index.isin(atm_contracts.index)]

        # Check if open_interest column exists
        if 'open_interest' in remaining_df.columns:
            other_contracts = remaining_df.nlargest(remaining, 'open_interest')
        else:
            # Fallback to volume or just take first remaining contracts
            if 'volume' in remaining_df.columns:
                other_contracts = remaining_df.nlargest(remaining, 'volume')
            else:
                other_contracts = remaining_df.head(remaining)

        result = pd.concat([atm_contracts, other_contracts])
    else:
        result = atm_contracts

    return result.drop(columns=['distance_from_atm'])


def _moneyness_near_the_money(df: pd.DataFrame, context: SelectionContext, limit: int) -> pd.DataFrame:
    """Select near-the-money contracts (within ±5% of underlying)."""
    if not context.underlying_price:
        logger.warning("underlying_price not available, falling back to open_interest")
        return _liquidity_high_open_interest(df, context, limit)

    if 'strike' not in df.columns:
        logger.warning("strike column not found")
        return df

    # Filter to strikes within ±5% of underlying
    price_range = context.underlying_price * 0.05
    lower_bound = context.underlying_price - price_range
    upper_bound = context.underlying_price + price_range

    near_money = df[(df['strike'] >= lower_bound) & (df['strike'] <= upper_bound)]

    # Sort by open interest within this range
    if 'open_interest' not in df.columns:
        logger.warning("open_interest column not found, returning near-the-money contracts only")
        return near_money.head(limit)

    if len(near_money) >= limit:
        return near_money.nlargest(limit, 'open_interest')
    else:
        # Fill remaining with highest OI outside range
        remaining = limit - len(near_money)
        far_contracts = df[~df.index.isin(near_money.index)].nlargest(remaining, 'open_interest')
        return pd.concat([near_money, far_contracts])


def _time_front_month(df: pd.DataFrame, context: SelectionContext, limit: int) -> pd.DataFrame:
    """Select contracts from the nearest expiration."""
    if 'expiration' not in df.columns:
        logger.warning("expiration column not found, falling back to open_interest")
        return _liquidity_high_open_interest(df, context, limit)

    # Convert to datetime if string
    df = df.copy()
    if df['expiration'].dtype == 'object':
        df['expiration'] = pd.to_datetime(df['expiration'])

    # Get nearest expiration
    nearest_expiry = df['expiration'].min()
    front_month = df[df['expiration'] == nearest_expiry]

    # Sort by open interest if available
    if len(front_month) >= limit:
        if 'open_interest' in front_month.columns:
            return front_month.nlargest(limit, 'open_interest')
        else:
            return front_month.head(limit)
    else:
        return front_month


def _time_balanced_expiry(df: pd.DataFrame, context: SelectionContext, limit: int) -> pd.DataFrame:
    """Select contracts balanced across multiple expirations."""
    if 'expiration' not in df.columns:
        logger.warning("expiration column not found, falling back to open_interest")
        return _liquidity_high_open_interest(df, context, limit)

    # Convert to datetime if string
    df = df.copy()
    if df['expiration'].dtype == 'object':
        df['expiration'] = pd.to_datetime(df['expiration'])

    # Get unique expirations sorted
    unique_expiries = sorted(df['expiration'].unique())

    # Distribute limit across expirations
    # Take up to 5 expirations: front, 1-2 mid-term, 1-2 long-term
    num_expiries = min(5, len(unique_expiries))
    per_expiry = limit // num_expiries

    selected = []
    for i in range(num_expiries):
        idx = int(i * (len(unique_expiries) - 1) / (num_expiries - 1)) if num_expiries > 1 else 0
        expiry = unique_expiries[idx]
        expiry_df = df[df['expiration'] == expiry]

        # Select by open interest if available, otherwise take first contracts
        if 'open_interest' in expiry_df.columns:
            expiry_contracts = expiry_df.nlargest(per_expiry, 'open_interest')
        else:
            expiry_contracts = expiry_df.head(per_expiry)
        selected.append(expiry_contracts)

    result = pd.concat(selected)

    # Fill any remaining slots with high OI if available
    if len(result) < limit:
        remaining = limit - len(result)
        remaining_df = df[~df.index.isin(result.index)]

        if 'open_interest' in remaining_df.columns:
            other = remaining_df.nlargest(remaining, 'open_interest')
        else:
            other = remaining_df.head(remaining)
        result = pd.concat([result, other])

    return result.head(limit)


def _time_long_dated(df: pd.DataFrame, context: SelectionContext, limit: int) -> pd.DataFrame:
    """Select long-dated contracts (LEAPS - 1+ year out)."""
    if 'expiration' not in df.columns:
        logger.warning("expiration column not found, falling back to open_interest")
        return _liquidity_high_open_interest(df, context, limit)

    # Convert to datetime if string
    df = df.copy()
    if df['expiration'].dtype == 'object':
        df['expiration'] = pd.to_datetime(df['expiration'])

    # Get latest expirations (top 25% by date)
    expiry_threshold = df['expiration'].quantile(0.75)
    long_dated = df[df['expiration'] >= expiry_threshold]

    if 'open_interest' not in df.columns:
        logger.warning("open_interest column not found, returning long-dated contracts only")
        return long_dated.head(limit)

    if len(long_dated) >= limit:
        return long_dated.nlargest(limit, 'open_interest')
    else:
        return long_dated


def _vol_high_iv(df: pd.DataFrame, context: SelectionContext, limit: int) -> pd.DataFrame:
    """Select contracts with highest implied volatility."""
    if 'implied_volatility' not in df.columns:
        logger.warning("implied_volatility column not found, falling back to open_interest")
        return _liquidity_high_open_interest(df, context, limit)

    # Filter out zero/null IV
    df_with_iv = df[df['implied_volatility'] > 0]
    if len(df_with_iv) >= limit:
        return df_with_iv.nlargest(limit, 'implied_volatility')
    else:
        return df_with_iv


def _vol_low_iv(df: pd.DataFrame, context: SelectionContext, limit: int) -> pd.DataFrame:
    """Select contracts with lowest implied volatility."""
    if 'implied_volatility' not in df.columns:
        logger.warning("implied_volatility column not found, falling back to open_interest")
        return _liquidity_high_open_interest(df, context, limit)

    # Filter out zero/null IV
    df_with_iv = df[df['implied_volatility'] > 0]
    if len(df_with_iv) >= limit:
        return df_with_iv.nsmallest(limit, 'implied_volatility')
    else:
        return df_with_iv


def _risk_put_hedges(df: pd.DataFrame, context: SelectionContext, limit: int) -> pd.DataFrame:
    """Select out-of-the-money puts suitable for portfolio hedging."""
    if 'option_type' not in df.columns:
        logger.warning("option_type column not found, falling back to open_interest")
        return _liquidity_high_open_interest(df, context, limit)

    # Filter to puts only
    puts = df[df['option_type'].str.lower() == 'put'].copy()

    if not context.underlying_price or 'strike' not in puts.columns:
        # Just return highest OI puts if available
        if 'open_interest' in puts.columns:
            return puts.nlargest(limit, 'open_interest') if len(puts) >= limit else puts
        else:
            return puts.head(limit)

    # Filter to OTM puts (strike < underlying)
    otm_puts = puts[puts['strike'] < context.underlying_price]

    if 'open_interest' not in puts.columns:
        logger.warning("open_interest column not found, returning OTM puts only")
        return otm_puts.head(limit)

    if len(otm_puts) >= limit:
        # Prioritize liquid OTM puts
        return otm_puts.nlargest(limit, 'open_interest')
    else:
        # Fill with any remaining puts
        remaining = limit - len(otm_puts)
        other_puts = puts[~puts.index.isin(otm_puts.index)].nlargest(remaining, 'open_interest')
        return pd.concat([otm_puts, other_puts])


def _risk_call_overwriting(df: pd.DataFrame, context: SelectionContext, limit: int) -> pd.DataFrame:
    """Select calls suitable for covered call writing."""
    if 'option_type' not in df.columns:
        logger.warning("option_type column not found, falling back to open_interest")
        return _liquidity_high_open_interest(df, context, limit)

    # Filter to calls only
    calls = df[df['option_type'].str.lower() == 'call'].copy()

    if not context.underlying_price or 'strike' not in calls.columns:
        # Just return highest OI calls if available
        if 'open_interest' in calls.columns:
            return calls.nlargest(limit, 'open_interest') if len(calls) >= limit else calls
        else:
            return calls.head(limit)

    # Prefer ATM and slightly OTM calls (strike >= underlying, within 10%)
    upper_bound = context.underlying_price * 1.10
    good_strikes = calls[(calls['strike'] >= context.underlying_price) &
                         (calls['strike'] <= upper_bound)]

    if 'open_interest' not in calls.columns:
        logger.warning("open_interest column not found, returning good strike calls only")
        return good_strikes.head(limit)

    if len(good_strikes) >= limit:
        return good_strikes.nlargest(limit, 'open_interest')
    else:
        # Fill with any remaining calls
        remaining = limit - len(good_strikes)
        other_calls = calls[~calls.index.isin(good_strikes.index)].nlargest(remaining, 'open_interest')
        return pd.concat([good_strikes, other_calls])


def _intel_unusual_activity(df: pd.DataFrame, context: SelectionContext, limit: int) -> pd.DataFrame:
    """Select contracts with unusual volume relative to open interest."""
    if 'volume' not in df.columns or 'open_interest' not in df.columns:
        logger.warning("volume or open_interest column not found, falling back to high_volume")
        return _liquidity_high_volume(df, context, limit)

    df = df.copy()

    # Calculate volume/OI ratio (avoid division by zero)
    df['vol_oi_ratio'] = np.where(
        df['open_interest'] > 0,
        df['volume'] / df['open_interest'],
        0.0
    )

    # Also require minimum absolute volume to avoid noise
    df_active = df[(df['volume'] >= 10) & (df['vol_oi_ratio'] > 0)]

    if len(df_active) >= limit:
        return df_active.nlargest(limit, 'vol_oi_ratio').drop(columns=['vol_oi_ratio'])
    else:
        return df_active.drop(columns=['vol_oi_ratio'])


def _intel_recent_trades(df: pd.DataFrame, context: SelectionContext, limit: int) -> pd.DataFrame:
    """Select most recently traded contracts."""
    if 'last_trade_time' not in df.columns:
        logger.warning("last_trade_time column not found, falling back to high_volume")
        return _liquidity_high_volume(df, context, limit)

    df = df.copy()

    # Filter to contracts with recent trades
    df_traded = df[df['last_trade_time'].notna()]

    if df_traded.empty:
        logger.warning("No contracts with trade timestamps, falling back to high_volume")
        return _liquidity_high_volume(df, context, limit)

    # Convert to datetime if string
    if df_traded['last_trade_time'].dtype == 'object':
        df_traded['last_trade_time'] = pd.to_datetime(df_traded['last_trade_time'])

    # Sort by most recent
    if len(df_traded) >= limit:
        return df_traded.nlargest(limit, 'last_trade_time')
    else:
        return df_traded


# Strategy registry
STRATEGIES: Dict[str, Callable[[pd.DataFrame, SelectionContext, int], pd.DataFrame]] = {
    # Liquidity
    'high_open_interest': _liquidity_high_open_interest,
    'high_volume': _liquidity_high_volume,
    'tight_spread': _liquidity_tight_spread,
    'liquidity_composite': _liquidity_composite,

    # Moneyness
    'at_the_money': _moneyness_at_the_money,
    'near_the_money': _moneyness_near_the_money,

    # Time
    'front_month': _time_front_month,
    'balanced_expiry': _time_balanced_expiry,
    'long_dated': _time_long_dated,

    # Volatility
    'high_iv': _vol_high_iv,
    'low_iv': _vol_low_iv,

    # Risk management
    'put_hedges': _risk_put_hedges,
    'call_overwriting': _risk_call_overwriting,

    # Market intelligence
    'unusual_activity': _intel_unusual_activity,
    'recent_trades': _intel_recent_trades,
}


def apply_selection_strategy(
    strategy: str,
    chains: List[Dict[str, Any]],
    context: Optional[SelectionContext] = None,
    limit: int = 100
) -> tuple[List[Dict[str, Any]], Dict[str, Any]]:
    """Apply a selection strategy to options chains data.

    Args:
        strategy: Name of the selection strategy
        chains: List of option contract dictionaries
        context: Selection context (underlying price, etc.)
        limit: Maximum number of contracts to return

    Returns:
        Tuple of (filtered contracts, metadata about selection)
    """
    if not chains:
        return [], {'strategy': strategy, 'contracts_filtered': 0, 'contracts_returned': 0}

    # Validate strategy
    if strategy not in STRATEGIES:
        logger.warning(f"Unknown strategy '{strategy}', using high_open_interest")
        strategy = 'high_open_interest'

    # Convert to DataFrame
    df = pd.DataFrame(chains)
    original_count = len(df)

    # Create context if not provided
    if context is None:
        context = SelectionContext.from_data({'chains': chains})

    # Apply strategy
    try:
        df_filtered = STRATEGIES[strategy](df, context, limit)

        # Ensure we don't exceed limit
        df_filtered = df_filtered.head(limit)

        # Convert back to list of dicts
        result = df_filtered.to_dict('records')

        metadata = {
            'strategy': strategy,
            'contracts_original': original_count,
            'contracts_returned': len(result),
            'contracts_filtered': original_count - len(result),
            'underlying_price': context.underlying_price,
        }

        logger.info(
            f"Applied strategy '{strategy}': {original_count} → {len(result)} contracts"
        )

        return result, metadata

    except Exception as e:
        logger.error(f"Error applying strategy '{strategy}': {e}", exc_info=True)
        # Fallback: return top N by open interest
        fallback = df.nlargest(limit, 'open_interest').to_dict('records') if 'open_interest' in df.columns else chains[:limit]
        metadata = {
            'strategy': strategy,
            'error': str(e),
            'fallback_used': True,
            'contracts_original': original_count,
            'contracts_returned': len(fallback),
        }
        return fallback, metadata
