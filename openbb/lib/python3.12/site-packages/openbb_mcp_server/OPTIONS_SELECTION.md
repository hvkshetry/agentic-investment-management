# Options Chain Selection Strategies

## Overview

The OpenBB MCP Server implements intelligent filtering for options chain data to prevent token overflow while preserving the most relevant contracts. Instead of returning thousands of contracts, the server applies institutional-grade selection strategies to return a focused subset.

## Usage

The `derivatives_options_chains` tool accepts two parameters for controlling selection:

- **`selection_strategy`**: The strategy to use for selecting contracts (default: `"high_open_interest"`)
- **`selection_limit`**: Maximum number of contracts to return (default: 100, range: 1-500)

### Example

```python
result = await session.call_tool(
    'derivatives_options_chains',
    arguments={
        'symbol': 'AAPL',
        'provider': 'yfinance',
        'selection_strategy': 'at_the_money',
        'selection_limit': 50
    }
)
```

## Available Strategies

### Liquidity-Based (Default)

#### `high_open_interest`
Selects contracts with the highest open interest, prioritizing the most liquid and established positions.

**Use case**: General analysis, ensuring liquid markets for entry/exit

#### `high_volume`
Selects contracts with the highest trading volume, focusing on actively traded positions.

**Use case**: Day trading, short-term strategies requiring immediate liquidity

#### `tight_spread`
Selects contracts with the tightest bid-ask spreads, minimizing transaction costs.

**Use case**: Precise entry/exit, reducing slippage on large trades

#### `liquidity_composite`
Combines open interest, volume, and spread metrics with weighted scoring.

**Use case**: Balanced liquidity assessment, institutional-grade filtering

### Moneyness-Based

#### `at_the_money`
Selects contracts closest to the current underlying price (within ±1 strike or delta ~0.5).

**Use case**: Directional plays with highest gamma, straddle/strangle strategies

#### `near_the_money`
Selects contracts within ±5% of the underlying price.

**Use case**: Focused analysis on relevant strike range, reducing noise

### Time-Based

#### `front_month`
Selects contracts from the nearest expiration only.

**Use case**: Short-term trading, earnings plays, theta decay strategies

#### `balanced_expiry`
Distributes selection across up to 5 different expirations (front, mid-term, long-term).

**Use case**: Calendar spreads, term structure analysis, comprehensive view

#### `long_dated`
Selects contracts from the top 25% of expirations (LEAPS - 1+ year out).

**Use case**: Long-term hedging, low theta decay, equity replacement strategies

### Volatility-Based

#### `high_iv`
Selects contracts with the highest implied volatility.

**Use case**: Volatility selling strategies, identifying rich options

#### `low_iv`
Selects contracts with the lowest implied volatility.

**Use case**: Volatility buying strategies, identifying cheap options

### Risk Management

#### `put_hedges`
Selects out-of-the-money puts suitable for portfolio hedging.

**Use case**: Downside protection, tail risk hedging, insurance strategies

#### `call_overwriting`
Selects calls suitable for covered call writing (ATM and slightly OTM within 10%).

**Use case**: Income generation, reducing cost basis, capped upside strategies

### Market Intelligence

#### `unusual_activity`
Selects contracts with unusual volume relative to open interest (vol/OI ratio > 1).

**Use case**: Detecting informed trading, order flow analysis, large trades

#### `recent_trades`
Selects most recently traded contracts based on last trade timestamp.

**Use case**: Real-time market activity, identifying current interest

## Response Metadata

Each response includes selection metadata in `extra.results_metadata.selection`:

```json
{
  "strategy": "at_the_money",
  "contracts_original": 2122,
  "contracts_returned": 50,
  "contracts_filtered": 2072,
  "underlying_price": 254.16
}
```

If a strategy encounters issues (missing required columns), it may include:

```json
{
  "strategy": "high_volume",
  "error": "'volume'",
  "fallback_used": true,
  "contracts_original": 2122,
  "contracts_returned": 100
}
```

## Implementation Details

### Column Handling

All strategies include defensive checks for required columns:
- Missing `open_interest`: Falls back to `volume` or returns unfiltered results
- Missing `volume`: Returns all contracts or falls back to other metrics
- Missing `strike`: Cannot filter by moneyness, returns all contracts
- Missing `expiration`: Cannot filter by time, returns all contracts

### Context-Aware Selection

The selection system extracts context from the options chain data:
- **Underlying price**: Used for moneyness calculations (ATM, OTM, ITM)
- **Available columns**: Determines which strategies can execute fully
- **Data quality**: Triggers fallback strategies when data is incomplete

### Performance

- **Token reduction**: Typically 94% reduction (from 335k+ to ~15k tokens)
- **Processing overhead**: Minimal (<100ms for 2000+ contracts)
- **Memory footprint**: Uses pandas for efficient in-memory filtering

## Architecture

```
OpenBB Provider (YFinance)
    ↓
Extract Data (2000+ contracts)
    ↓
Apply Selection Strategy
    ↓
Filter to Limit (default 100)
    ↓
Transform & Return with Metadata
```

### Files

- **`options_selection.py`**: Core selection logic with 15 strategies
- **`__init__.py`**: Provider patching and parameter injection
- **`main.py`**: MCP schema customization for parameter exposure

## Extending

To add a new selection strategy:

1. Add strategy function in `options_selection.py`:
```python
def _category_strategy_name(df: pd.DataFrame, context: SelectionContext, limit: int) -> pd.DataFrame:
    """Description of strategy."""
    # Check for required columns
    if 'required_column' not in df.columns:
        logger.warning("required_column not found, falling back")
        return _liquidity_high_open_interest(df, context, limit)

    # Apply strategy logic
    filtered = df[df['required_column'] > threshold]
    return filtered.head(limit)
```

2. Register in `STRATEGIES` dict:
```python
STRATEGIES = {
    # ...
    'strategy_name': _category_strategy_name,
}
```

3. Update `main.py` schema enum to expose in MCP tool

4. Test with edge cases (missing columns, empty data, etc.)
